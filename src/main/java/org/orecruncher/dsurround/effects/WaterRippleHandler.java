package org.orecruncher.dsurround.effects;

import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.client.particle.Particle;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.fluid.FluidState;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import org.orecruncher.dsurround.Client;
import org.orecruncher.dsurround.config.WaterRippleStyle;
import org.orecruncher.dsurround.effects.particles.WaterRippleParticle;
import org.orecruncher.dsurround.lib.GameUtils;

@Environment(EnvType.CLIENT)
public class WaterRippleHandler {

    // Fudge factor because the height algo is off.
    private static final double LIQUID_HEIGHT_ADJUST = (1D / 9D) + 0.1D;

    // Hook for Rain particle effect to generate a ripple instead of a splash
    public static void spawnRippleOnBlock(final ClientWorld world, final Vec3d position) {
        final BlockPos pos = new BlockPos(position.x, position.y - 0.01D, position.z);
        final FluidState fluidState = world.getFluidState(pos);
        if (fluidState.isEmpty() || !fluidState.isStill()) return;

        final float actualHeight = fluidState.getHeight(world, pos) + pos.getY();
        addWaterRipple(world, position.x, actualHeight + LIQUID_HEIGHT_ADJUST, position.z);
    }

    private static boolean doRipples() {
        return Client.Config.blockEffects.waterRippleStyle != WaterRippleStyle.NONE;
    }

    private static void addWaterRipple(ClientWorld world, double x, double y, double z) {
        var ripple = new WaterRippleParticle(
                Client.Config.blockEffects.waterRippleStyle,
                world, x, y, z);
        GameUtils.getParticleManager().addParticle(ripple);
    }

    public static boolean createRippleParticle(ClientWorld world, Particle particle, Vec3d position) {
        if (!doRipples()) return false;
        WaterRippleHandler.spawnRippleOnBlock(world, position);

        // Expire the particle generated by Minecraft rather than returning null.
        if (particle != null) {
            particle.setPos(0, 0, 0);
            particle.markDead();
        }
        return true;
    }
}
